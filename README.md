# rust-study

## weak 1

### rust 개발 환경

#### rustc
빌드 도구

#### cargo
패키지 매니저

##### cargo new [project]
프로젝트 생성

##### cargo check
에러 검사

##### cargo build
빌드

##### cargo run
빌드 후 실행

##### Cargo.toml
의존성 관리

### 변수의 기본
1. 정적 타입
2. 기본적으로 불변하지만 mut 키워드로 변경 가능

### 매크로
1. context 기반으로 변수의 범위를 통제하므로 위생적
2. 하지만 본문에 치환되므로 부분적으로 위생적

#### print!, format!
가변 인자가 필요할 때 매크로를 사용

- positional parameters
- named parameters
- formatting parameters

### 러스트의 장점

- 컴파일 타임 메모리 안정성
- 정의되지 않은 행동이 없음
- 현대적 언어 기능들

### 컴파일 타임 보장

- 초기화되지 않은 변수 에러
- 메모리 노수 에러
- 중복 메모리 해제 에러
- 메모리 해제 후 사용 에러
- null 포인터 에러
- 뮤텍스 잠금 상태 에러
- 스레드간 공유 자원 에러
- 반복자 무효화 에러

### 런타임 보장
    
- 배열 접근 체크
- 정수 오버플로우
    - debug 빌드는 패닉
    - release 빌드는 래핑

### 타입

#### 스칼라 타입

#### 복합 타입

- 배열: 같은 타입
- 튜플: 다른 타입

### 참조

- 참조 변수의 값을 가져올 때는 자동 역참조 됨
- 참조 변수의 값을 변경할 때는 역참조(*)를 해야 함
- 원본이 참조 변수 보다 오래 살아있지 않으면 컴파일 타임 에러

### 슬라이스
컬렉션의 일부를 참조하는 뷰

- &a[0..a.len()]
- 슬라이스는 참조이기 때문에 원본이 더 오래 살아있어야 함
- 슬라이스는 데이터를 읽을 수 있지만 수정할 수 없음

#### String

- 문자열을 담는 객체
- Vec<u8>
- format!
- utf8

#### &str

- 문자열 슬라이스에 대한 참조
- 항상 유효한 문자열을 가리킴

### 함수

- 다른 언어와 비슷하지만 반환 타입을 뒤에 기술
- 헤더를 추가하거나 전방 선언이 필요없음
- 마지막 줄에 ; 가 없으면 반환 값이 됨
- void 타입 대신 () 단위 타입을 사용
- 오버로딩이 지원도지 않음
- 매개변수의 기본 값은 지원하지 않음
- 함수의 매개변수에는 제네릭을 적용할 수 있음

#### 메소드

- 사용자 타입의 함수
- 사용자 타입의 인스턴스는 &self

### 타입의 변환

- 넓은 타입으로는 x.into() 
- 좁은 타입으로는 i16::from(x)

### for 반복문

- for i in [start]..[end] end 는 포함되지 않음
